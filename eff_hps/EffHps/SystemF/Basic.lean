
import EffHps.Notation

import Batteries.Logic
import Batteries.Data.Vector
import Mathlib.Logic.Relation

open Relation
open Batteries

namespace SystemF


inductive Kind where
  | star : Kind

inductive ty (Var‚Çú : Type) : Type where
  | var : Var‚Çú ‚Üí ty Var‚Çú
  | unit : ty Var‚Çú
  | pair : ty Var‚Çú ‚Üí ty Var‚Çú ‚Üí ty Var‚Çú
  | record : (Fin n ‚Üí ty Var‚Çú) ‚Üí ty Var‚Çú
  | bool : ty Var‚Çú
  | fn : ty Var‚Çú ‚Üí ty Var‚Çú ‚Üí ty Var‚Çú
  | pi : (Var‚Çú  ‚Üí ty Var‚Çú) ‚Üí ty Var‚Çú

def ty.squash : ty (ty Var‚Çú) ‚Üí ty Var‚Çú
  | .var e => e
  | .unit => .unit
  | .pair a b => .pair a.squash b.squash
  | .record f => .record (fun i => (f i).squash)
  | .bool => .bool
  | .fn A B => .fn A.squash B.squash
  | .pi f => .pi fun B => (f (.var B)).squash


def Ty := {Var‚Çú : Type} ‚Üí ty Var‚Çú

-- 1 free variable
def Ty‚ÇÅ := {Var‚Çú : Type} ‚Üí Var‚Çú ‚Üí ty Var‚Çú

def Ty.subst : Ty‚ÇÅ ‚Üí Ty ‚Üí Ty :=
  fun s t => (s t).squash

example : Ty.subst (fun X => ty.var X) .unit = .unit (Var‚Çú:=Var‚Çú) := rfl


inductive Term (Var : ty Var‚Çú ‚Üí Type) : ty Var‚Çú ‚Üí Type  where
  | var : Var T ‚Üí Term Var T
  | unit : Term Var .unit
  | pair : Term Var A ‚Üí Term Var B ‚Üí Term Var (.pair A B)
  | p‚ÇÅ : Term Var (.pair A B) ‚Üí Term Var A
  | p‚ÇÇ : Term Var (.pair A B) ‚Üí Term Var B
  | record : ((i : Fin n) ‚Üí Term Var (f i)) ‚Üí Term Var (.record f)
  | proj : Term Var (.record f) ‚Üí (i : Fin _) ‚Üí Term Var (f i)
  | ifte : Term Var .bool ‚Üí Term Var A ‚Üí Term Var A ‚Üí Term Var A
  | true : Term Var .bool
  | false : Term Var .bool
  | lam : (A : ty Var‚Çú) ‚Üí (Var A ‚Üí Term Var B) ‚Üí Term Var (.fn A B)
  | app : Term Var (.fn A B) ‚Üí Term Var A ‚Üí Term Var B
  | lam‚Çú : {f : Var‚Çú ‚Üí ty Var‚Çú} ‚Üí ((A : Var‚Çú) ‚Üí Term Var (f A)) ‚Üí Term Var (.pi fun A => f A)
  -- | app‚Çú : Term Var (.pi f) ‚Üí (B : ty Var‚Çú) ‚Üí Term Var _

example {Var‚Çú : Type} {Var : ty Var‚Çú ‚Üí Type} {A B : ty Var‚Çú} : Term Var (.fn A (.fn B A)) := .lam A fun x => .lam B fun y => .var x
example {Var‚Çú : Type} {Var : ty Var‚Çú ‚Üí Type} : Term Var (.pi fun X => (.fn (.var X) (.var X))) :=
  .lam‚Çú fun A => .lam (.var A) fun x => .var x


def Term.squash : Term (Term Var) A ‚Üí Term Var A
  | .var i => i
  | .unit => .unit
  | .pair a b => .pair a.squash b.squash
  | .p‚ÇÅ ab => .p‚ÇÅ ab.squash
  | .p‚ÇÇ ab => .p‚ÇÇ ab.squash
  | .record f => .record (fun i => (f i).squash)
  | .proj (f:=f) r i => .proj r.squash i
  | .true => .true
  | .false => .false
  | .ifte b t e => .ifte b.squash t.squash e.squash
  | .lam A f => .lam A fun x => (f (.var x)).squash
  | .app f e => .app f.squash e.squash
  | .lam‚Çú f => .lam‚Çú fun A => (f A).squash

-- 1 free variable
def Term‚ÇÅ {Var‚Çú : Type} (A B : ty Var‚Çú) := {Var : ty Var‚Çú ‚Üí Type} ‚Üí (Var A ‚Üí Term Var B)

def Term.subst : Term‚ÇÅ A B ‚Üí Term Var A ‚Üí Term Var B :=
  fun s t => (s t).squash

example {Var‚Çú} {A : ty Var‚Çú} {Var} : (Term.lam (Var:=Var) A fun x => .var x) = (Term.lam A fun x => .var x) := rfl
example {Var‚Çú} {A : ty Var‚Çú} {Var : ty Var‚Çú ‚Üí Type} : Term.subst (fun x => .var x) .unit = .unit (Var:=Var) := rfl

def Var‚Çú : Type := sorry
def Var : ty Var‚Çú ‚Üí Type := sorry

-- def Rename‚Çú (Œ® Œ¶ : Con‚Çú) := Œ¶‚àã* ‚Üí Œ®‚àã*
-- def Subst‚Çú (Œ® Œ¶ : Con‚Çú) := Œ¶‚àã* ‚Üí Ty Œ®

-- def Rename‚Çú.extend {Œ® Œ¶} : Rename‚Çú Œ® Œ¶ ‚Üí Rename‚Çú (Œ®;*) (Œ¶;*)
--   | _, .zero => .zero
--   | œÅ‚Çú, .succ i => .succ (œÅ‚Çú i)

-- def Rename‚Çú.id : (Œ¶ : Con‚Çú) ‚Üí Rename‚Çú Œ¶ Œ¶ := fun _ => _root_.id
-- prefix : max "ùüô·µ£‚Çú" => Rename‚Çú.id

-- def Rename‚Çú.id_extend {Œ¶} : (ùüô·µ£‚Çú Œ¶).extend = ùüô·µ£‚Çú (Œ¶;*) := by
--   funext i
--   cases i
--   all_goals simp [extend, id]

-- def Rename‚Çú.nil : ‚àÄ {Œ¶}, Rename‚Çú Œ¶ ‚àÖ :=
--   fun _ => by contradiction

-- def Rename‚Çú.nil_eta {Œ¶} : (œÅ' : Rename‚Çú Œ¶ ‚àÖ) ‚Üí œÅ' = Rename‚Çú.nil := by
--   intro œÅ'
--   funext i
--   contradiction


-- def Ty.rename‚Çú {Œ® Œ¶} : Ty Œ¶ ‚Üí Rename‚Çú Œ® Œ¶ ‚Üí Ty Œ®
--   | .var i, œÅ‚Çú => .var (œÅ‚Çú i)
--   | .unit, _ => .unit
--   | .record f, œÅ => .record (fun i => (f i).rename‚Çú œÅ)
--   | .pair A B, œÅ‚Çú => .pair (A.rename‚Çú œÅ‚Çú) (B.rename‚Çú œÅ‚Çú)
--   | .bool, _ => .bool
--   | .fn A B, œÅ‚Çú => .fn (A.rename‚Çú œÅ‚Çú) (B.rename‚Çú œÅ‚Çú)
--   | .pi A, œÅ‚Çú => .pi (A.rename‚Çú œÅ‚Çú.extend)
-- notation : max A "{{" œÅ‚Çú "}}·µ£‚Çú" => Ty.rename‚Çú A œÅ‚Çú

-- def Rename‚Çú.id_rfl {Œ¶} : {A : Ty Œ¶} ‚Üí A{{ùüô·µ£‚Çú _}}·µ£‚Çú = A
--   | .var i => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.rename‚Çú]
--     funext i
--     apply id_rfl
--   | .fn A B => by
--     simp [Ty.rename‚Çú]
--     constructor
--     apply id_rfl
--     apply id_rfl
--   | .pi A => by
--     simp [Ty.rename‚Çú]
--     rw [id_extend]
--     apply id_rfl
--   | .pair A B => by
--     simp [Ty.rename‚Çú]
--     constructor
--     apply id_rfl
--     apply id_rfl

-- def Ty.wk {Œ¶} : Ty Œ¶ ‚Üí Ty (Œ¶;*) := fun t => (t.rename‚Çú .succ)

-- def Subst‚Çú.extend {Œ® Œ¶} : Subst‚Çú Œ® Œ¶ ‚Üí Subst‚Çú (Œ®;*) (Œ¶;*)
--   | _, .zero => .var .zero
--   | œÉ‚Çú, .succ i => (œÉ‚Çú i).wk

-- def Ty.subst‚Çú {Œ® Œ¶} : Ty Œ¶ ‚Üí Subst‚Çú Œ® Œ¶ ‚Üí Ty Œ®
--   | .var i, œÉ‚Çú => œÉ‚Çú i
--   | .unit, _ => .unit
--   | .record f, œÉ‚Çú => .record (fun i => (f i).subst‚Çú œÉ‚Çú)
--   | .pair A B, œÉ‚Çú => .pair (A.subst‚Çú œÉ‚Çú) (B.subst‚Çú œÉ‚Çú)
--   | .bool, _ => .bool
--   | .fn A B, œÉ‚Çú => .fn (A.subst‚Çú œÉ‚Çú) (B.subst‚Çú œÉ‚Çú)
--   | .pi A, œÉ‚Çú => .pi (A.subst‚Çú œÉ‚Çú.extend)
-- notation : max A "{{" œÉ‚Çú "}}‚Çõ‚Çú" => Ty.subst‚Çú A œÉ‚Çú

-- def Subst‚Çú.cons {Œ® Œ¶} : Subst‚Çú Œ® Œ¶ ‚Üí Ty Œ® ‚Üí Subst‚Çú Œ® (Œ¶;*)
--   | _, A, .zero => A
--   | œÉ‚Çú, _, .succ i => œÉ‚Çú i
-- notation : 100 œÉ‚Çú "; " A => Subst‚Çú.cons œÉ‚Çú A

-- def Subst‚Çú.id : (Œ¶ : Con‚Çú) ‚Üí Subst‚Çú Œ¶ Œ¶ := fun _ => (.var ¬∑)
-- prefix : max "ùüô‚Çõ‚Çú" => Subst‚Çú.id

-- def Ty.subst‚Çú‚ÇÄ {Œ¶}: Ty (Œ¶;*) ‚Üí Ty Œ¶ ‚Üí Ty Œ¶ :=
--   fun A B => A{{ùüô‚Çõ‚Çú _; B}}‚Çõ‚Çú
-- notation : max A "[[" B "]]‚Çõ‚Çú" => Ty.subst‚Çú‚ÇÄ A B

-- def Rename‚Çú.comp {Œ¶'' Œ¶' Œ¶} : Rename‚Çú Œ¶'' Œ¶' ‚Üí Rename‚Çú Œ¶' Œ¶ ‚Üí Rename‚Çú Œ¶'' Œ¶ :=
--   fun œÅ‚Çú' œÅ‚Çú => œÅ‚Çú' ‚àò œÅ‚Çú

-- def Subst‚Çú.comp {Œ¶'' Œ¶' Œ¶} : Subst‚Çú Œ¶'' Œ¶' ‚Üí Subst‚Çú Œ¶' Œ¶ ‚Üí Subst‚Çú Œ¶'' Œ¶ :=
--   fun œÉ‚Çú' œÉ‚Çú i => (œÉ‚Çú i).subst‚Çú œÉ‚Çú'

-- def Subst‚Çú.comp·µ£‚Çõ {Œ¶'' Œ¶' Œ¶} : Rename‚Çú Œ¶'' Œ¶' ‚Üí Subst‚Çú Œ¶' Œ¶ ‚Üí Subst‚Çú Œ¶'' Œ¶ :=
--   fun œÅ‚Çú œÉ‚Çú i => (œÉ‚Çú i).rename‚Çú œÅ‚Çú
-- def Subst‚Çú.comp‚Çõ·µ£ {Œ¶'' Œ¶' Œ¶} : Subst‚Çú Œ¶'' Œ¶' ‚Üí Rename‚Çú Œ¶' Œ¶ ‚Üí Subst‚Çú Œ¶'' Œ¶ :=
--   fun œÉ‚Çú œÅ‚Çú => œÉ‚Çú ‚àò œÅ‚Çú

-- def Rename‚Çú.extend_comp {Œ¶'' Œ¶' Œ¶} {f : Rename‚Çú Œ¶'' Œ¶'} {g : Rename‚Çú Œ¶' Œ¶} : extend (comp f g) = comp f.extend g.extend :=
--   funext fun i =>
--   match i with
--   | .zero => rfl
--   | .succ _ => rfl

-- def Rename‚Çú.ren_comp {Œ¶'' Œ¶' Œ¶} {œÅ‚Çú' : Rename‚Çú Œ¶'' Œ¶'} {œÅ‚Çú : Rename‚Çú Œ¶' Œ¶} : {t : Ty Œ¶} ‚Üí t{{comp œÅ‚Çú' œÅ‚Çú}}·µ£‚Çú = t{{œÅ‚Çú}}·µ£‚Çú{{œÅ‚Çú'}}·µ£‚Çú
--   | .var _ => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.rename‚Çú]
--     funext i
--     apply ren_comp
--   | .fn _ _ => congrArg‚ÇÇ Ty.fn ren_comp ren_comp
--   | .pi _ => congrArg Ty.pi (Eq.trans (congrArg _ extend_comp) ren_comp)
--   | .pair _ _  => congrArg‚ÇÇ Ty.pair ren_comp ren_comp

-- def Subst‚Çú.extend_comp·µ£‚Çõ {Œ¶'' Œ¶' Œ¶} {f : Rename‚Çú Œ¶'' Œ¶'} {g : Subst‚Çú Œ¶' Œ¶} : extend (Subst‚Çú.comp·µ£‚Çõ f g) = comp·µ£‚Çõ f.extend g.extend :=
--   funext fun i =>
--   match i with
--   | .zero => rfl
--   | .succ _ => by
--     simp [extend, comp·µ£‚Çõ, Ty.wk]
--     rw [‚ÜêRename‚Çú.ren_comp, ‚ÜêRename‚Çú.ren_comp]
--     rfl
-- def Subst‚Çú.extend_comp‚Çõ·µ£ {Œ¶'' Œ¶' Œ¶} {f : Subst‚Çú Œ¶'' Œ¶'} {g : Rename‚Çú Œ¶' Œ¶} : extend (Subst‚Çú.comp‚Çõ·µ£ f g) = comp‚Çõ·µ£ f.extend g.extend :=
--   funext fun i =>
--   match i with
--   | .zero => rfl
--   | .succ _ => rfl

-- def Subst‚Çú.subs_comp·µ£‚Çõ : {t : Ty Œ¶} ‚Üí t{{comp·µ£‚Çõ œÅ‚Çú œÉ‚Çú}}‚Çõ‚Çú = t{{œÉ‚Çú}}‚Çõ‚Çú{{œÅ‚Çú}}·µ£‚Çú
--   | .var _ => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.subst‚Çú, Ty.rename‚Çú]
--     funext i
--     apply subs_comp·µ£‚Çõ
--   | .fn _ _ => congrArg‚ÇÇ Ty.fn subs_comp·µ£‚Çõ subs_comp·µ£‚Çõ
--   | .pi _ => congrArg Ty.pi (Eq.trans (congrArg _ extend_comp·µ£‚Çõ) subs_comp·µ£‚Çõ)
--   | .pair _ _  => congrArg‚ÇÇ Ty.pair subs_comp·µ£‚Çõ subs_comp·µ£‚Çõ
-- def Subst‚Çú.subs_comp‚Çõ·µ£ : {t : Ty Œ¶} ‚Üí t{{comp‚Çõ·µ£ œÉ‚Çú œÅ‚Çú}}‚Çõ‚Çú = t{{œÅ‚Çú}}·µ£‚Çú{{œÉ‚Çú}}‚Çõ‚Çú
--   | .var _ => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.subst‚Çú, Ty.rename‚Çú]
--     funext i
--     apply subs_comp‚Çõ·µ£
--   | .fn _ _ => congrArg‚ÇÇ Ty.fn subs_comp‚Çõ·µ£ subs_comp‚Çõ·µ£
--   | .pi _ => congrArg Ty.pi (Eq.trans (congrArg _ extend_comp‚Çõ·µ£) subs_comp‚Çõ·µ£)
--   | .pair _ _  => congrArg‚ÇÇ Ty.pair subs_comp‚Çõ·µ£ subs_comp‚Çõ·µ£

-- def Subst‚Çú.extend_comp : extend (Subst‚Çú.comp f g) = comp f.extend g.extend :=
--   funext fun i =>
--   match i with
--   | .zero => rfl
--   | .succ _ => by
--     simp [extend, comp, Ty.wk]
--     rw [‚Üêsubs_comp·µ£‚Çõ, ‚Üêsubs_comp‚Çõ·µ£]
--     rfl

-- def Subst‚Çú.subs_comp : {t : Ty Œ¶} ‚Üí t{{comp œÉ‚Çú œÉ‚Çú'}}‚Çõ‚Çú = t{{œÉ‚Çú'}}‚Çõ‚Çú{{œÉ‚Çú}}‚Çõ‚Çú
--   | .var _ => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.subst‚Çú]
--     funext i
--     apply subs_comp
--   | .fn _ _ => congrArg‚ÇÇ Ty.fn subs_comp subs_comp
--   | .pi _ => congrArg Ty.pi (Eq.trans (congrArg _ extend_comp) subs_comp)
--   | .pair _ _  => congrArg‚ÇÇ Ty.pair subs_comp subs_comp

-- def Subst‚Çú.subst‚Çú‚ÇÄ_rename‚Çú : {A : Ty _} ‚Üí A[[B]]‚Çõ‚Çú{{œÅ‚Çú}}·µ£‚Çú = A{{œÅ‚Çú.extend}}·µ£‚Çú[[B{{œÅ‚Çú}}·µ£‚Çú]]‚Çõ‚Çú := by
--   intro A
--   simp [Ty.subst‚Çú‚ÇÄ]
--   rw [‚ÜêSubst‚Çú.subs_comp·µ£‚Çõ]
--   rw [‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--   congr
--   funext i
--   cases i with
--   | zero => rfl
--   | succ i => rfl

-- def Subst‚Çú.id_extend : (ùüô‚Çõ‚Çú Œ¶).extend = ùüô‚Çõ‚Çú _ :=
--   funext fun i =>
--   match i with
--   | .zero => rfl
--   | .succ _ => rfl

-- def Subst‚Çú.subs_id : {t : Ty Œ¶} ‚Üí t{{ùüô‚Çõ‚Çú _}}‚Çõ‚Çú = t
--   | .var _ => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.subst‚Çú]
--     funext i
--     apply subs_id
--   | .fn _ _ => congrArg‚ÇÇ Ty.fn subs_id subs_id
--   | .pi _ => congrArg Ty.pi (Eq.trans (congrArg _ id_extend) subs_id)
--   | .pair _ _  => congrArg‚ÇÇ Ty.pair subs_id subs_id

-- def Subst‚Çú.of_Rename‚Çú : Rename‚Çú Œ® Œ¶ ‚Üí Subst‚Çú Œ® Œ¶
--   | œÅ‚Çú => fun i => .var <| œÅ‚Çú i
-- def Subst‚Çú.of_Rename‚Çú_extend : extend (of_Rename‚Çú œÅ‚Çú) = of_Rename‚Çú œÅ‚Çú.extend := by
--   funext i
--   cases i with
--   | zero => rfl
--   | succ i => rfl
-- def Subst‚Çú.of_Rename‚Çú_lemma : {A : Ty Œ¶} ‚Üí A{{of_Rename‚Çú œÅ‚Çú}}‚Çõ‚Çú = A{{œÅ‚Çú}}·µ£‚Çú
--   | .var _ => rfl
--   | .unit => rfl
--   | .bool => rfl
--   | .record f => by
--     simp [Ty.subst‚Çú, Ty.rename‚Çú]
--     funext i
--     apply of_Rename‚Çú_lemma
--   | .fn _ _ => congrArg‚ÇÇ Ty.fn of_Rename‚Çú_lemma of_Rename‚Çú_lemma
--   | .pi A => congrArg Ty.pi (Eq.trans (congrArg (A.subst‚Çú ¬∑) of_Rename‚Çú_extend) of_Rename‚Çú_lemma)
--   | .pair _ _ => congrArg‚ÇÇ Ty.pair of_Rename‚Çú_lemma of_Rename‚Çú_lemma

-- def Subst‚Çú.nil : ‚àÄ {Œ¶}, Subst‚Çú Œ¶ ‚àÖ :=
--   fun i => by contradiction

-- def Subst‚Çú.nil_eta : (œÉ‚Çú : Subst‚Çú Œ¶ ‚àÖ) ‚Üí œÉ' = Subst‚Çú.nil := by
--   intro _
--   funext i
--   contradiction

-- def nil_ren_sub' : (A : Ty ‚àÖ) ‚Üí A{{Rename‚Çú.nil}}·µ£‚Çú{{œÉ}}‚Çõ‚Çú = A{{Subst‚Çú.nil}}‚Çõ‚Çú := by
--   intro A
--   rw [‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--   congr
--   rw [‚ÜêSubst‚Çú.nil_eta (œÉ‚Çú:=œÉ.comp‚Çõ·µ£ Rename‚Çú.nil)]
-- def nil_ren_sub : (A : Ty ‚àÖ) ‚Üí A{{Rename‚Çú.nil}}·µ£‚Çú{{œÉ}}‚Çõ‚Çú = A{{Rename‚Çú.nil}}·µ£‚Çú := by
--   intro A
--   rw [nil_ren_sub', ‚ÜêSubst‚Çú.of_Rename‚Çú_lemma]
--   congr
--   rw [‚ÜêSubst‚Çú.nil_eta (œÉ‚Çú:=Subst‚Çú.of_Rename‚Çú Rename‚Çú.nil)]
--   assumption

-- inductive Con : Con‚Çú ‚Üí Type where
--   | nil : Con Œ¶
--   | cons : Con Œ¶ ‚Üí Ty Œ¶ ‚Üí Con Œ¶
-- infixl : 90 "; " => Con.cons
-- namespace Con

-- def rename‚Çú : Con Œ¶ ‚Üí Rename‚Çú Œ® Œ¶ ‚Üí Con Œ®
--   | .nil, _ => .nil
--   | .cons Œì A, œÅ‚Çú => Œì.rename‚Çú œÅ‚Çú ; A.rename‚Çú œÅ‚Çú
-- notation : max Œì "{{" œÅ‚Çú "}}·µ£‚Çú" => Con.rename‚Çú Œì œÅ‚Çú

-- def wk : Con Œ¶ ‚Üí Con (Œ¶;*) := (¬∑.rename‚Çú .succ)
-- def subst‚Çú : Con Œ¶ ‚Üí Subst‚Çú Œ® Œ¶ ‚Üí Con Œ®
--   | .nil, _ => .nil
--   | .cons Œì A, œÉ‚Çú => Œì.subst‚Çú œÉ‚Çú ; A.subst‚Çú œÉ‚Çú
-- notation : max Œì "{{" œÉ‚Çú "}}‚Çõ‚Çú" => Con.subst‚Çú Œì œÉ‚Çú

-- def subst‚Çú‚ÇÄ : Con (Œ¶;*) ‚Üí Ty Œ¶ ‚Üí Con Œ¶ :=
--   fun Œì B => Œì{{ùüô‚Çõ‚Çú _; B}}‚Çõ‚Çú
-- notation : max Œì "[[" B "]]‚Çõ‚Çú" => Con.subst‚Çú‚ÇÄ Œì B

-- inductive Member : (Œ¶ : Con‚Çú) ‚Üí Con Œ¶ ‚Üí Ty Œ¶ ‚Üí Type where
--   | zero : Member Œ¶ (Œì; A) A
--   | succ : Member Œ¶ Œì A ‚Üí Member Œ¶ (Œì; B) A
-- notation : 90 Œ¶: 90 " / " Œì: 90 " ‚àã " A: 90 => Member Œ¶ Œì A

-- def Member.rename‚Çú : Œ¶ / Œì ‚àã A ‚Üí (œÅ‚Çú : Rename‚Çú Œ® Œ¶) ‚Üí Œ® / Œì.rename‚Çú œÅ‚Çú ‚àã A.rename‚Çú œÅ‚Çú
--   | .zero, œÅ‚Çú => .zero
--   | .succ i, œÅ‚Çú => .succ (i.rename‚Çú œÅ‚Çú)
-- notation : max i "{{" œÅ‚Çú "}}·µ£‚Çú" => Member.rename‚Çú i œÅ‚Çú
-- def Member.wk : Œ¶ / Œì ‚àã A ‚Üí Œ¶;* / Œì.wk ‚àã A.wk :=
--   fun i => i.rename‚Çú .succ

-- def Member.subst‚Çú : Œ¶ / Œì ‚àã A ‚Üí (œÉ‚Çú : Subst‚Çú Œ® Œ¶) ‚Üí Œ® / Œì.subst‚Çú œÉ‚Çú ‚àã A.subst‚Çú œÉ‚Çú
--   | .zero, œÉ‚Çú => .zero
--   | .succ i, œÉ‚Çú => .succ (i.subst‚Çú œÉ‚Çú)
-- notation : max i "{{" œÉ‚Çú "}}‚Çõ‚Çú" => Member.subst‚Çú i œÉ‚Çú

-- end Con

-- inductive Term : (Œ¶ : Con‚Çú) ‚Üí Con Œ¶ ‚Üí Ty Œ¶ ‚Üí Type where
--   | var : Œ¶ / Œì ‚àã A ‚Üí Term Œ¶ Œì A
--   | unit : Term Œ¶ Œì .unit
--   | record : ((i : Fin n) ‚Üí Term Œ¶ Œì (f i)) ‚Üí Term Œ¶ Œì (.record f)
--   | proj : {f : Fin n ‚Üí Ty Œ¶} ‚Üí Term Œ¶ Œì (.record f) ‚Üí (i : Fin n) ‚Üí Term Œ¶ Œì (f i)
--   | pair : Term Œ¶ Œì A ‚Üí Term Œ¶ Œì B ‚Üí  Term Œ¶ Œì (.pair A B)
--   | p‚ÇÅ : Term Œ¶ Œì (.pair A B) ‚Üí Term Œ¶ Œì A
--   | p‚ÇÇ : Term Œ¶ Œì (.pair A B) ‚Üí Term Œ¶ Œì B
--   | true : Term Œ¶ Œì .bool
--   | false : Term Œ¶ Œì .bool
--   | ifte : Term Œ¶ Œì .bool ‚Üí Term Œ¶ Œì A ‚Üí Term Œ¶ Œì A ‚Üí Term Œ¶ Œì A
--   | lam : (A : Ty Œ¶) ‚Üí Term Œ¶ (Œì; A) B ‚Üí Term Œ¶ Œì (A ‚áí B)
--   | app : Term Œ¶ Œì (A ‚áí B) ‚Üí Term Œ¶ Œì A ‚Üí Term Œ¶ Œì B
--   | lam‚Çú : Term (Œ¶;*) Œì.wk A ‚Üí Term Œ¶ Œì (.pi A)
--   | app‚Çú : Term Œ¶ Œì (.pi A) ‚Üí (B : Ty Œ¶) ‚Üí Term Œ¶ Œì A[[B]]‚Çõ‚Çú
-- notation : 90 Œ¶: 90 " / " Œì: 90 " ‚ä¢ " A: 90 => Term Œ¶ Œì A

-- def Rename (Œ® Œ¶) (Œî : Con Œ®) (Œì : Con Œ¶) (œÅ‚Çú : Rename‚Çú Œ® Œ¶) :=
--   ‚àÄ (A : Ty Œ¶), Œ¶ / Œì ‚àã A ‚Üí Œ® / Œî ‚àã A{{œÅ‚Çú}}·µ£‚Çú
-- def Subst (Œ® Œ¶) (Œî : Con Œ®) (Œì : Con Œ¶) (œÅ‚Çú : Rename‚Çú Œ® Œ¶) :=
--   ‚àÄ (A : Ty Œ¶), Œ¶ / Œì ‚àã A ‚Üí Œ® / Œî ‚ä¢ A{{œÅ‚Çú}}·µ£‚Çú

-- def Rename.extend : Rename Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Rename Œ® Œ¶ (Œî; A{{œÅ‚Çú}}·µ£‚Çú) (Œì; A) œÅ‚Çú
--   | _, _, .zero => .zero
--   | œÅ, _, .succ i => .succ (œÅ _ i)

-- def Rename.extend' : Rename Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Rename (Œ®;*) (Œ¶;*) Œî.wk Œì.wk œÅ‚Çú.extend :=
--   fun œÅ =>
--   fun {A} i =>
--   match Œì with
--   | .nil => by contradiction
--   | .cons Œì A =>
--   match i with
--   | .zero =>
--     have : A{{œÅ‚Çú}}·µ£‚Çú.wk = A.wk{{œÅ‚Çú.extend}}·µ£‚Çú := by {
--       simp [Ty.wk]
--       rw [‚ÜêRename‚Çú.ren_comp, ‚ÜêRename‚Çú.ren_comp]
--       congr
--     }
--     this ‚ñ∏ (œÅ _ .zero).wk
--   | .succ i =>
--     let œÅ' : Rename _ _ _ _ _ := fun _ => œÅ _ ‚àò .succ
--     œÅ'.extend' _ i

-- def subst‚Çú‚ÇÄ_rename‚Çú : {B : Ty (Œ¶;*)} ‚Üí B[[A]]‚Çõ‚Çú{{œÅ‚Çú}}·µ£‚Çú = B{{œÅ‚Çú.extend}}·µ£‚Çú[[A{{œÅ‚Çú}}·µ£‚Çú]]‚Çõ‚Çú := by {
--   intro B
--   simp [Ty.subst‚Çú‚ÇÄ]
--   rw [‚ÜêSubst‚Çú.subs_comp·µ£‚Çõ, ‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--   congr
--   funext i
--   cases i with
--   | zero => rfl
--   | succ i => rfl
-- }

-- def Term.rename : Œ¶ / Œì ‚ä¢ A ‚Üí Rename Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Œ® / Œî ‚ä¢ A{{œÅ‚Çú}}·µ£‚Çú
--   | var i, œÅ => var (œÅ _ i)
--   | unit, œÅ => .unit
--   | .record g, œÅ => .record (fun i => (g i).rename œÅ)
--   | .proj (f:=f) r i , œÅ => .proj (r.rename œÅ) i
--   | pair a b, œÅ => .pair (a.rename œÅ) (b.rename œÅ)
--   | p‚ÇÅ ab, œÅ => .p‚ÇÅ (ab.rename œÅ)
--   | p‚ÇÇ ab, œÅ => .p‚ÇÇ (ab.rename œÅ)
--   | true, œÅ => .true
--   | false, œÅ => .false
--   | ifte b t e, œÅ => .ifte (b.rename œÅ) (t.rename œÅ) (e.rename œÅ)
--   | lam B e, œÅ => .lam B{{œÅ‚Çú}}·µ£‚Çú (e.rename œÅ.extend)
--   | app f x, œÅ => .app (f.rename œÅ) (x.rename œÅ)
--   | lam‚Çú e, œÅ => .lam‚Çú (e.rename œÅ.extend')
--   | app‚Çú f B, œÅ => subst‚Çú‚ÇÄ_rename‚Çú ‚ñ∏ .app‚Çú (f.rename œÅ) B{{œÅ‚Çú}}·µ£‚Çú
-- notation : max A "{{" œÅ "}}·µ£" => Term.rename A œÅ

-- def Rename.id : (Œì : Con Œ¶) ‚Üí Rename Œ¶ Œ¶ Œì Œì (ùüô·µ£‚Çú _)
--   | _, _ => Rename‚Çú.id_rfl ‚ñ∏ _root_.id
-- prefix : max "ùüô·µ£" => Rename.id

-- def Rename.nil : (Œì : Con Œ¶) ‚Üí Rename Œ¶ .nil Œì .nil Rename‚Çú.nil :=
--   fun Œì =>
--   fun _ i => by contradiction

-- def Rename.wk : Rename Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí (A : Ty _) ‚Üí Rename Œ® Œ¶ (Œî; A) Œì œÅ‚Çú
--   | œÅ, _, _, i => .succ (œÅ _ i)

-- def Rename.rest : Rename Œ® Œ¶ Œî (Œì; A) œÅ‚Çú ‚Üí Rename Œ® Œ¶ Œî Œì œÅ‚Çú :=
--   fun œÅ =>
--   fun _ i => œÅ _ (.succ i)

-- def Term.wk : Œ¶ / Œì ‚ä¢ A ‚Üí Œ¶ / Œì; B ‚ä¢ A
--   | t => (Rename‚Çú.id_rfl (A:=A)) ‚ñ∏ Term.rename t (Rename.wk (ùüô·µ£ Œì) B)

-- def Subst.extend : Subst Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Subst Œ® Œ¶ (Œî; A{{œÅ‚Çú}}·µ£‚Çú) (Œì; A) œÅ‚Çú
--   | _, _, .zero => .var .zero
--   | œÉ, _, .succ i => (œÉ _ i).wk

-- def Term.rename‚Çú : Œ¶ / Œì ‚ä¢ A ‚Üí (œÅ : Rename‚Çú Œ® Œ¶) ‚Üí Œ® / Œì{{œÅ}}·µ£‚Çú ‚ä¢ A{{œÅ}}·µ£‚Çú
--   | var i, œÅ‚Çú => var (i.rename‚Çú œÅ‚Çú)
--   | unit, œÅ‚Çú => .unit
--   | record f, œÅ‚Çú => .record (fun i => (f i).rename‚Çú œÅ‚Çú)
--   | proj (f:=f) r i, œÅ‚Çú => .proj (r.rename‚Çú œÅ‚Çú) i
--   | pair a b, œÅ‚Çú => .pair (a.rename‚Çú œÅ‚Çú) (b.rename‚Çú œÅ‚Çú)
--   | p‚ÇÅ ab, œÅ‚Çú => .p‚ÇÅ (ab.rename‚Çú œÅ‚Çú)
--   | p‚ÇÇ ab, œÅ‚Çú => .p‚ÇÇ (ab.rename‚Çú œÅ‚Çú)
--   | true, œÅ‚Çú => .true
--   | false, œÅ‚Çú => .false
--   | ifte b t e, œÅ‚Çú => .ifte (b.rename‚Çú œÅ‚Çú) (t.rename‚Çú œÅ‚Çú) (e.rename‚Çú œÅ‚Çú)
--   | lam B e, œÅ‚Çú => .lam (B.rename‚Çú œÅ‚Çú) (e.rename‚Çú œÅ‚Çú)
--   | app f x, œÅ‚Çú => .app (f.rename‚Çú œÅ‚Çú) (x.rename‚Çú œÅ‚Çú)
--   | lam‚Çú e, œÅ‚Çú =>
--     have this : ‚àÄ {Œ¶ Œ®} {Œì : Con Œ¶} {œÅ‚Çú : Rename‚Çú Œ® Œ¶}, Œì.wk{{œÅ‚Çú.extend}}·µ£‚Çú = Œì{{œÅ‚Çú}}·µ£‚Çú.wk := by {
--       intro Œ¶ Œ® Œì œÉ‚Çú
--       simp [Con.wk]
--       induction Œì with
--       | nil => trivial
--       | cons Œì B ih =>
--         simp [Con.rename‚Çú, Con.subst‚Çú]
--         constructor
--         apply ih
--         rw [‚ÜêRename‚Çú.ren_comp, ‚ÜêRename‚Çú.ren_comp]
--         congr
--     }
--     .lam‚Çú (this ‚ñ∏ e.rename‚Çú œÅ‚Çú.extend)
--   | app‚Çú (A:=C) f B, œÅ‚Çú =>
--     have : C{{œÅ‚Çú.extend}}·µ£‚Çú[[B{{œÅ‚Çú}}·µ£‚Çú]]‚Çõ‚Çú = C[[B]]‚Çõ‚Çú{{œÅ‚Çú}}·µ£‚Çú := by {
--       simp [Ty.subst‚Çú‚ÇÄ]
--       rw [‚ÜêSubst‚Çú.subs_comp·µ£‚Çõ, ‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--       congr
--       funext i
--       cases i with
--       | zero => rfl
--       | succ i => rfl
--     }
--     this ‚ñ∏ .app‚Çú (f.rename‚Çú œÅ‚Çú) (B.rename‚Çú œÅ‚Çú)
-- notation : max t "{{" œÅ‚Çú "}}·µ£‚Çú" => Term.rename‚Çú t œÅ‚Çú

-- def Term.subst‚Çú : Œ¶ / Œì ‚ä¢ A ‚Üí (œÉ : Subst‚Çú Œ® Œ¶) ‚Üí Œ® / Œì.subst‚Çú œÉ ‚ä¢ A.subst‚Çú œÉ
--   | var i, œÉ‚Çú => var (i.subst‚Çú œÉ‚Çú)
--   | unit, œÉ‚Çú => .unit
--   | record f, œÉ‚Çú => .record (fun i => (f i).subst‚Çú œÉ‚Çú)
--   | proj (f:=f) r i, œÉ‚Çú => .proj (r.subst‚Çú œÉ‚Çú) i
--   | pair a b, œÉ‚Çú => .pair (a.subst‚Çú œÉ‚Çú) (b.subst‚Çú œÉ‚Çú)
--   | p‚ÇÅ ab, œÉ‚Çú => .p‚ÇÅ (ab.subst‚Çú œÉ‚Çú)
--   | p‚ÇÇ ab, œÉ‚Çú => .p‚ÇÇ (ab.subst‚Çú œÉ‚Çú)
--   | true, œÉ‚Çú => .true
--   | false, œÉ‚Çú => .false
--   | ifte b t e, œÉ‚Çú => .ifte (b.subst‚Çú œÉ‚Çú) (t.subst‚Çú œÉ‚Çú) (e.subst‚Çú œÉ‚Çú)
--   | lam B e, œÉ‚Çú => .lam (B.subst‚Çú œÉ‚Çú) (e.subst‚Çú œÉ‚Çú)
--   | app f x, œÉ‚Çú => .app (f.subst‚Çú œÉ‚Çú) (x.subst‚Çú œÉ‚Çú)
--   | lam‚Çú e, œÉ‚Çú =>
--     have this : ‚àÄ {Œ¶ Œ®} {Œì : Con Œ¶} {œÉ‚Çú : Subst‚Çú Œ® Œ¶}, Œì.wk{{œÉ‚Çú.extend}}‚Çõ‚Çú = Œì{{œÉ‚Çú}}‚Çõ‚Çú.wk := by {
--       intro Œ¶ Œ® Œì œÉ‚Çú
--       simp [Con.wk]
--       induction Œì with
--       | nil => trivial
--       | cons Œì B ih =>
--         simp [Con.rename‚Çú, Con.subst‚Çú]
--         constructor
--         apply ih
--         rw [‚ÜêSubst‚Çú.subs_comp·µ£‚Çõ, ‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--         congr
--     }
--     .lam‚Çú (this ‚ñ∏ e.subst‚Çú œÉ‚Çú.extend)
--   | app‚Çú (A:=C) f B, œÉ‚Çú =>
--     have : C{{œÉ‚Çú.extend}}‚Çõ‚Çú[[B{{œÉ‚Çú}}‚Çõ‚Çú]]‚Çõ‚Çú = C[[B]]‚Çõ‚Çú{{œÉ‚Çú}}‚Çõ‚Çú := by {
--       simp [Ty.subst‚Çú‚ÇÄ]
--       rw [‚ÜêSubst‚Çú.subs_comp, ‚ÜêSubst‚Çú.subs_comp]
--       congr
--       funext i
--       cases i with
--       | zero => rfl
--       | succ i =>
--         simp [Subst‚Çú.comp, Subst‚Çú.extend, Subst‚Çú.cons, Subst‚Çú.id, Ty.subst‚Çú, Ty.wk]
--         rw [‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£, ‚ÜêSubst‚Çú.subs_id (t:=œÉ‚Çú i), ‚ÜêSubst‚Çú.subs_comp]
--         congr
--     }
--     this ‚ñ∏ .app‚Çú (f.subst‚Çú œÉ‚Çú) (B.subst‚Çú œÉ‚Çú)
-- notation : max t "{{" œÅ‚Çú "}}‚Çõ‚Çú" => Term.subst‚Çú t œÅ‚Çú


-- def Term.subst‚Çú‚ÇÄ : Œ¶;* / Œì.wk ‚ä¢ A ‚Üí (B : Ty Œ¶) ‚Üí Œ¶ / Œì ‚ä¢ A[[B]]‚Çõ‚Çú :=
--   fun t B =>
--   have : ‚àÄ {Œ¶} {Œì: Con Œ¶} {B}, Œì.wk{{ùüô‚Çõ‚Çú _; B}}‚Çõ‚Çú = Œì := by {
--     intro Œ¶ Œì B
--     induction Œì with
--     | nil => trivial
--     | cons Œì C ih =>
--       simp [Con.wk, Con.rename‚Çú, Con.subst‚Çú]
--       constructor
--       assumption
--       rw [‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£, ‚ÜêSubst‚Çú.subs_id (t:=C), ‚ÜêSubst‚Çú.subs_comp]
--       congr
--   }
--   @this _ Œì B ‚ñ∏ t{{ùüô‚Çõ‚Çú _; B}}‚Çõ‚Çú
-- notation : max t "[[" B "]]‚Çõ‚Çú" => Term.subst‚Çú‚ÇÄ t B

-- def Subst.extend' : Subst Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Subst (Œ®;*) (Œ¶;*) Œî.wk Œì.wk œÅ‚Çú.extend :=
--   fun œÉ =>
--   fun {A} i =>
--   match Œì with
--   | .nil => by contradiction
--   | .cons Œì A =>
--   match i with
--   | .zero =>
--     have : Œ®;* / Œî{{Con‚Çú.Member.succ}}·µ£‚Çú ‚ä¢ A{{œÅ‚Çú}}·µ£‚Çú{{Con‚Çú.Member.succ}}·µ£‚Çú = Œ®;* / Œî.wk ‚ä¢ A{{Con‚Çú.Member.succ}}·µ£‚Çú{{œÅ‚Çú.extend}}·µ£‚Çú := by {
--       simp [Con.wk]
--       apply congrArg‚ÇÇ
--       rfl
--       rw [‚ÜêRename‚Çú.ren_comp, ‚ÜêRename‚Çú.ren_comp]
--       congr
--     }
--     this ‚ñ∏ (œÉ _ .zero).rename‚Çú .succ
--   | .succ i =>
--     let œÉ' : Subst _ _ _ _ _ := fun _ => œÉ _ ‚àò .succ
--     œÉ'.extend' _ i


-- def Term.subst : Œ¶ / Œì ‚ä¢ A ‚Üí Subst Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Œ® / Œî ‚ä¢ A{{œÅ‚Çú}}·µ£‚Çú
--   | var i, œÉ => œÉ _ i
--   | unit, œÉ => .unit
--   | record f, œÉ => .record (fun i => (f i).subst œÉ)
--   | proj (f:=f) r i, œÉ => .proj (r.subst œÉ) i
--   | pair a b, œÉ => .pair (a.subst œÉ) (b.subst œÉ)
--   | p‚ÇÅ ab, œÉ => .p‚ÇÅ (ab.subst œÉ)
--   | p‚ÇÇ ab, œÉ => .p‚ÇÇ (ab.subst œÉ)
--   | true, œÉ => .true
--   | false, œÉ => .false
--   | ifte b t e, œÉ => .ifte (b.subst œÉ) (t.subst œÉ) (e.subst œÉ)
--   | lam B e, œÉ => .lam B{{œÅ‚Çú}}·µ£‚Çú (e.subst œÉ.extend)
--   | app f x, œÉ => .app (f.subst œÉ) (x.subst œÉ)
--   | lam‚Çú e, œÉ => .lam‚Çú (e.subst œÉ.extend')
--   | app‚Çú (A:=C) f B, œÉ =>
--     have : C{{œÅ‚Çú.extend}}·µ£‚Çú[[B{{œÅ‚Çú}}·µ£‚Çú]]‚Çõ‚Çú = C[[B]]‚Çõ‚Çú{{œÅ‚Çú}}·µ£‚Çú := by {
--       simp [Ty.subst‚Çú‚ÇÄ]
--       rw [‚ÜêSubst‚Çú.subs_comp·µ£‚Çõ, ‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--       congr
--       funext i
--       cases i with
--       | zero => rfl
--       | succ i => rfl
--     }
--     this ‚ñ∏ .app‚Çú (f.subst œÉ) B{{œÅ‚Çú}}·µ£‚Çú
-- notation : max A "{{" œÉ "}}‚Çõ" => Term.subst A œÉ

-- def Subst.cons : Subst Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Œ® / Œî ‚ä¢ A{{œÅ‚Çú}}·µ£‚Çú ‚Üí Subst Œ® Œ¶ Œî (Œì; A) œÅ‚Çú
--   | _, t, _, .zero => t
--   | œÉ‚Çú, _, _, .succ i => œÉ‚Çú _ i
-- notation : 100 œÉ‚Çú "; " A => Subst.cons œÉ‚Çú A

-- def Subst.id : (Œì : Con Œ¶) ‚Üí Subst Œ¶ Œ¶ Œì Œì (ùüô·µ£‚Çú _) :=
--   fun _ _ => Rename‚Çú.id_rfl ‚ñ∏ (.var ¬∑)
-- prefix : max "ùüô‚Çõ" => Subst.id

-- def Term.subst‚ÇÄ : Œ¶ / Œì; A ‚ä¢ B ‚Üí Œ¶ / Œì ‚ä¢ A ‚Üí Œ¶ / Œì ‚ä¢ B :=
--   fun t s =>
--   have : ‚àÄ {A}, Œ¶ / Œì ‚ä¢ A = Œ¶ / Œì ‚ä¢ A{{ùüô·µ£‚Çú _}}·µ£‚Çú := by {
--     intro A
--     congr
--     exact Rename‚Çú.id_rfl.symm
--   }
--   let œÉ : Subst _ _ _ _ _ := ùüô‚Çõ _; (this ‚ñ∏ s)
--   this ‚ñ∏ t{{œÉ}}‚Çõ
-- notation : max t "[[" s "]]‚Çõ" => Term.subst‚ÇÄ t s

-- def update {T : Type} : (Fin n ‚Üí T) ‚Üí Fin n ‚Üí T ‚Üí Fin n ‚Üí T :=
--   fun f i t =>
--   fun j =>
--   if i = j then
--     t
--   else
--     f j

-- inductive SmallStep : Œ¶ / Œì ‚ä¢ A ‚Üí Œ¶ / Œì ‚ä¢ A ‚Üí Prop where
--   | Œ≤_app : SmallStep (.app (.lam B e) x) e[[x]]‚Çõ
--   | Œ≤_app‚Çú : SmallStep (.app‚Çú (.lam‚Çú e) B) e[[B]]‚Çõ‚Çú
--   | Œ≤_proj : SmallStep (.proj (.record f) i) (f i)
--   | Œ≤_p‚ÇÅ : SmallStep (.p‚ÇÅ (.pair a b)) a
--   | Œ≤_p‚ÇÇ : SmallStep (.p‚ÇÇ (.pair a b)) b
--   | Œ≤_ifte‚ÇÅ : SmallStep (.ifte .true t e) t
--   | Œ≤_ifte‚ÇÇ : SmallStep (.ifte .false t e) e
--   | Œæ_record : SmallStep (f i) t ‚Üí SmallStep (.record f) (.record (update f i t))
--   | Œæ_proj : SmallStep r r' ‚Üí SmallStep (.proj r i) (.proj r' i)
--   | Œæ_pair‚ÇÅ : SmallStep a a' ‚Üí SmallStep (.pair a b) (.pair a' b)
--   | Œæ_pair‚ÇÇ : SmallStep b b' ‚Üí SmallStep (.pair a b) (.pair a b')
--   | Œæ_p‚ÇÅ : SmallStep ab ab' ‚Üí SmallStep (.p‚ÇÅ ab) (.p‚ÇÅ ab')
--   | Œæ_p‚ÇÇ : SmallStep ab ab' ‚Üí SmallStep (.p‚ÇÇ ab) (.p‚ÇÇ ab')
--   | Œæ_ifte‚ÇÄ : SmallStep b b' ‚Üí SmallStep (.ifte b t e) (.ifte b' t e)
--   | Œæ_ifte‚ÇÅ : SmallStep t t' ‚Üí SmallStep (.ifte b t e) (.ifte b t' e)
--   | Œæ_ifte‚ÇÇ : SmallStep e e' ‚Üí SmallStep (.ifte b t e) (.ifte b t e')
--   | Œæ_lam : SmallStep e e' ‚Üí SmallStep (.lam _ e) (.lam _ e')
--   | Œæ_app‚ÇÅ : SmallStep f f' ‚Üí SmallStep (.app f x) (.app f' x)
--   | Œæ_app‚ÇÇ : SmallStep x x' ‚Üí SmallStep (.app f x) (.app f x')
--   | Œæ_lam‚Çú : SmallStep e e' ‚Üí SmallStep (.lam‚Çú e) (.lam‚Çú e')
--   | Œæ_app‚Çú : SmallStep f f' ‚Üí SmallStep (.app‚Çú f B) (.app‚Çú f' B)
-- infix: 30 " ‚ü∂‚Çõ " => SmallStep

-- def MultiStep (t t' : Œ¶ / Œì ‚ä¢ A) := TransGen SmallStep t t'
-- infix: 30 " ‚ü∂‚Çõ+ " => MultiStep

-- namespace Extrinsic

-- inductive Term : (Œ¶ : Con‚Çú) ‚Üí Con Œ¶ ‚Üí Type where
--   | var : Œ¶ / Œì ‚àã A ‚Üí Term Œ¶ Œì
--   | unit : Term Œ¶ Œì
--   | record : ((i : Fin n) ‚Üí Term Œ¶ Œì) ‚Üí Term Œ¶ Œì
--   | proj : Term Œ¶ Œì ‚Üí (i : Fin n) ‚Üí Term Œ¶ Œì
--   | pair : Term Œ¶ Œì ‚Üí Term Œ¶ Œì ‚Üí  Term Œ¶ Œì
--   | p‚ÇÅ : Term Œ¶ Œì ‚Üí Term Œ¶ Œì
--   | p‚ÇÇ : Term Œ¶ Œì ‚Üí Term Œ¶ Œì
--   | true : Term Œ¶ Œì
--   | false : Term Œ¶ Œì
--   | ifte : Term Œ¶ Œì ‚Üí Term Œ¶ Œì ‚Üí Term Œ¶ Œì ‚Üí Term Œ¶ Œì
--   | lam : (A : Ty Œ¶) ‚Üí Term Œ¶ (Œì; A) ‚Üí Term Œ¶ Œì
--   | app : Term Œ¶ Œì ‚Üí Term Œ¶ Œì ‚Üí Term Œ¶ Œì
--   | lam‚Çú : Term (Œ¶;*) Œì.wk ‚Üí Term Œ¶ Œì
--   | app‚Çú : Term Œ¶ Œì ‚Üí (B : Ty Œ¶) ‚Üí Term Œ¶ Œì
-- notation : 90 Œ¶: 90 " / " Œì: 90 " ‚ä¢ " => Term Œ¶ Œì

-- inductive Typing : (t : Œ¶ / Œì ‚ä¢) ‚Üí Ty Œ¶ ‚Üí Prop where
--   | var : (i : Œ¶ / Œì ‚àã A) ‚Üí Typing (.var i) A
--   | unit : Typing .unit .unit
--   | record : ((i : Fin n) ‚Üí Typing (g i) (f i))‚Üí Typing (.record g) (.record f)
--   | proj : Typing r (.record f) ‚Üí Typing (.proj r i) (f i)
--   | pair : Typing a A ‚Üí Typing b B ‚Üí Typing (.pair a b) (.pair A B)
--   | p‚ÇÅ : Typing ab (.pair A B) ‚Üí Typing (.p‚ÇÅ ab) A
--   | p‚ÇÇ : Typing ab (.pair A B) ‚Üí Typing (.p‚ÇÇ ab) B
--   | true : Typing .true .bool
--   | false : Typing .false .bool
--   | ifte : Typing b .bool ‚Üí Typing t A ‚Üí Typing e A ‚Üí Typing (.ifte b t e) A
--   | lam : Typing (Œì:=Œì;A) e B ‚Üí Typing (.lam A e) (A ‚áí B)
--   | app : Typing f (A ‚áí B) ‚Üí Typing x A ‚Üí Typing (.app f x) B
--   | lam‚Çú : Typing (Œ¶:=Œ¶;*) e B ‚Üí Typing (.lam‚Çú e) (.pi B)
--   | app‚Çú : Typing (Œ¶:=Œ¶) f (.pi A) ‚Üí Typing (.app‚Çú f B) A[[B]]‚Çõ‚Çú

-- def Term.rename‚Çú : Œ¶ / Œì ‚ä¢ ‚Üí (œÅ : Rename‚Çú Œ® Œ¶) ‚Üí Œ® / Œì{{œÅ}}·µ£‚Çú ‚ä¢
--   | var i, œÅ‚Çú => var (i.rename‚Çú œÅ‚Çú)
--   | unit, œÅ‚Çú => .unit
--   | record f, œÅ‚Çú => .record (fun i => (f i).rename‚Çú œÅ‚Çú)
--   | proj r i, œÅ‚Çú => .proj (r.rename‚Çú œÅ‚Çú) i
--   | pair a b, œÅ‚Çú => .pair (a.rename‚Çú œÅ‚Çú) (b.rename‚Çú œÅ‚Çú)
--   | p‚ÇÅ ab, œÅ‚Çú => .p‚ÇÅ (ab.rename‚Çú œÅ‚Çú)
--   | p‚ÇÇ ab, œÅ‚Çú => .p‚ÇÇ (ab.rename‚Çú œÅ‚Çú)
--   | true, œÅ‚Çú => .true
--   | false, œÅ‚Çú => .false
--   | ifte b t e, œÅ‚Çú => .ifte (b.rename‚Çú œÅ‚Çú) (t.rename‚Çú œÅ‚Çú) (e.rename‚Çú œÅ‚Çú)
--   | lam B e, œÅ‚Çú => .lam (B.rename‚Çú œÅ‚Çú) (e.rename‚Çú œÅ‚Çú)
--   | app f x, œÅ‚Çú => .app (f.rename‚Çú œÅ‚Çú) (x.rename‚Çú œÅ‚Çú)
--   | lam‚Çú e, œÅ‚Çú =>
--     have this : ‚àÄ {Œ¶ Œ®} {Œì : Con Œ¶} {œÅ‚Çú : Rename‚Çú Œ® Œ¶}, Œì.wk{{œÅ‚Çú.extend}}·µ£‚Çú = Œì{{œÅ‚Çú}}·µ£‚Çú.wk := by {
--       intro Œ¶ Œ® Œì œÉ‚Çú
--       simp [Con.wk]
--       induction Œì with
--       | nil => trivial
--       | cons Œì B ih =>
--         simp [Con.rename‚Çú, Con.subst‚Çú]
--         constructor
--         apply ih
--         rw [‚ÜêRename‚Çú.ren_comp, ‚ÜêRename‚Çú.ren_comp]
--         congr
--     }
--     .lam‚Çú (this ‚ñ∏ e.rename‚Çú œÅ‚Çú.extend)
--   | .app‚Çú f B, œÅ‚Çú =>
--     .app‚Çú (f.rename‚Çú œÅ‚Çú) (B.rename‚Çú œÅ‚Çú)
-- notation : max t "{{" œÅ‚Çú "}}·µ£‚Çú" => Term.rename‚Çú t œÅ‚Çú

-- def Term.rename : Œ¶ / Œì ‚ä¢ ‚Üí Rename Œ® Œ¶ Œî Œì œÅ‚Çú ‚Üí Œ® / Œî ‚ä¢
--   | var i, œÅ => var (œÅ _ i)
--   | unit, œÅ => .unit
--   | record f, œÅ => .record (fun i => (f i).rename œÅ)
--   | proj r i, œÅ => .proj (r.rename œÅ) i
--   | pair a b, œÅ => .pair (a.rename œÅ) (b.rename œÅ)
--   | p‚ÇÅ ab, œÅ => .p‚ÇÅ (ab.rename œÅ)
--   | p‚ÇÇ ab, œÅ => .p‚ÇÇ (ab.rename œÅ)
--   | true, œÅ => .true
--   | false, œÅ => .false
--   | ifte b t e, œÅ => .ifte (b.rename œÅ) (t.rename œÅ) (e.rename œÅ)
--   | lam B e, œÅ => .lam B{{œÅ‚Çú}}·µ£‚Çú (e.rename œÅ.extend)
--   | app f x, œÅ => .app (f.rename œÅ) (x.rename œÅ)
--   | lam‚Çú e, œÅ => .lam‚Çú (e.rename œÅ.extend')
--   | app‚Çú f B, œÅ => .app‚Çú (f.rename œÅ) B{{œÅ‚Çú}}·µ£‚Çú
-- notation : max A "{{" œÅ "}}·µ£" => Term.rename A œÅ

-- def Term.wk : Œ¶ / Œì ‚ä¢ ‚Üí Œ¶ / Œì; B ‚ä¢
--   | t => t{{(Rename.wk (ùüô·µ£ Œì) B)}}·µ£

-- def Term.subst‚Çú : Œ¶ / Œì ‚ä¢ ‚Üí (œÉ : Subst‚Çú Œ® Œ¶) ‚Üí Œ® / Œì.subst‚Çú œÉ ‚ä¢
--   | var i, œÉ‚Çú => var (i.subst‚Çú œÉ‚Çú)
--   | unit, œÉ‚Çú => .unit
--   | record f, œÉ‚Çú => .record (fun i => (f i).subst‚Çú œÉ‚Çú)
--   | proj r i, œÉ‚Çú => .proj (r.subst‚Çú œÉ‚Çú) i
--   | pair a b, œÉ‚Çú => .pair (a.subst‚Çú œÉ‚Çú) (b.subst‚Çú œÉ‚Çú)
--   | p‚ÇÅ ab, œÉ‚Çú => .p‚ÇÅ (ab.subst‚Çú œÉ‚Çú)
--   | p‚ÇÇ ab, œÉ‚Çú => .p‚ÇÇ (ab.subst‚Çú œÉ‚Çú)
--   | true, œÉ‚Çú => .true
--   | false, œÉ‚Çú => .false
--   | ifte b t e, œÉ‚Çú => .ifte (b.subst‚Çú œÉ‚Çú) (t.subst‚Çú œÉ‚Çú) (e.subst‚Çú œÉ‚Çú)
--   | lam B e, œÉ‚Çú => .lam (B.subst‚Çú œÉ‚Çú) (e.subst‚Çú œÉ‚Çú)
--   | app f x, œÉ‚Çú => .app (f.subst‚Çú œÉ‚Çú) (x.subst‚Çú œÉ‚Çú)
--   | lam‚Çú e, œÉ‚Çú =>
--     have this : ‚àÄ {Œ¶ Œ®} {Œì : Con Œ¶} {œÉ‚Çú : Subst‚Çú Œ® Œ¶}, Œì.wk{{œÉ‚Çú.extend}}‚Çõ‚Çú = Œì{{œÉ‚Çú}}‚Çõ‚Çú.wk := by {
--       intro Œ¶ Œ® Œì œÉ‚Çú
--       simp [Con.wk]
--       induction Œì with
--       | nil => trivial
--       | cons Œì B ih =>
--         simp [Con.rename‚Çú, Con.subst‚Çú]
--         constructor
--         apply ih
--         rw [‚ÜêSubst‚Çú.subs_comp·µ£‚Çõ, ‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£]
--         congr
--     }
--     .lam‚Çú (this ‚ñ∏ e.subst‚Çú œÉ‚Çú.extend)
--   | app‚Çú f B, œÉ‚Çú => .app‚Çú (f.subst‚Çú œÉ‚Çú) (B.subst‚Çú œÉ‚Çú)
-- notation : max t "{{" œÅ‚Çú "}}‚Çõ‚Çú" => Term.subst‚Çú t œÅ‚Çú


-- def Term.subst‚Çú‚ÇÄ : Œ¶;* / Œì.wk ‚ä¢ ‚Üí (B : Ty Œ¶) ‚Üí Œ¶ / Œì ‚ä¢ :=
--   fun t B =>
--   have : ‚àÄ {Œ¶} {Œì: Con Œ¶} {B}, Œì.wk{{ùüô‚Çõ‚Çú _; B}}‚Çõ‚Çú = Œì := by {
--     intro Œ¶ Œì B
--     induction Œì with
--     | nil => trivial
--     | cons Œì C ih =>
--       simp [Con.wk, Con.rename‚Çú, Con.subst‚Çú]
--       constructor
--       assumption
--       rw [‚ÜêSubst‚Çú.subs_comp‚Çõ·µ£, ‚ÜêSubst‚Çú.subs_id (t:=C), ‚ÜêSubst‚Çú.subs_comp]
--       congr
--   }
--   @this _ Œì B ‚ñ∏ t{{ùüô‚Çõ‚Çú _; B}}‚Çõ‚Çú
-- notation : max t "[[" B "]]‚Çõ‚Çú" => Term.subst‚Çú‚ÇÄ t B

-- def Subst (Œ¶) (Œî : Con Œ¶) (Œì : Con Œ¶) :=
--   ‚àÄ (A : Ty Œ¶), Œ¶ / Œì ‚àã A ‚Üí Œ¶ / Œî ‚ä¢

-- def Subst.extend : Subst Œ¶ Œî Œì ‚Üí Subst Œ¶ (Œî; A) (Œì; A)
--   | _, _, .zero => .var .zero
--   | œÉ, _, .succ i => (œÉ _ i).wk
-- def Subst.extend' : Subst Œ¶ Œî Œì ‚Üí Subst (Œ¶;*) Œî.wk Œì.wk :=
--   fun œÉ =>
--   fun A i =>
--   match Œì with
--   | .nil => by contradiction
--   | .cons Œì A =>
--   match i with
--   | .zero => (œÉ _ .zero).rename‚Çú .succ
--   | .succ i =>
--     let œÉ' : Subst _ _ _ := fun _ => œÉ _ ‚àò .succ
--     œÉ'.extend' _ i
-- def Term.subst : Œ¶ / Œì ‚ä¢ ‚Üí Subst Œ¶ Œî Œì ‚Üí Œ¶ / Œî ‚ä¢
--   | var i, œÉ => œÉ _ i
--   | unit, œÉ => .unit
--   | record f, œÉ => .record (fun i => (f i).subst œÉ)
--   | proj r i, œÉ => .proj (r.subst œÉ) i
--   | pair a b, œÉ => .pair (a.subst œÉ) (b.subst œÉ)
--   | p‚ÇÅ ab, œÉ => .p‚ÇÅ (ab.subst œÉ)
--   | p‚ÇÇ ab, œÉ => .p‚ÇÇ (ab.subst œÉ)
--   | true, œÉ => .true
--   | false, œÉ => .false
--   | ifte b t e, œÉ => .ifte (b.subst œÉ) (t.subst œÉ) (e.subst œÉ)
--   | lam B e, œÉ => .lam B (e.subst œÉ.extend)
--   | app f x, œÉ => .app (f.subst œÉ) (x.subst œÉ)
--   | lam‚Çú e, œÉ => .lam‚Çú (e.subst œÉ.extend')
--   | app‚Çú f B, œÉ => .app‚Çú (f.subst œÉ) B
-- notation : max A "{{" œÉ "}}‚Çõ" => Term.subst A œÉ

-- def Subst.cons : Subst Œ¶ Œî Œì ‚Üí Œ¶ / Œî ‚ä¢ ‚Üí Subst Œ¶ Œî (Œì; A)
--   | _, t, _, .zero => t
--   | œÉ‚Çú, _, _, .succ i => œÉ‚Çú _ i
-- notation : 100 œÉ‚Çú "; " A => Subst.cons œÉ‚Çú A

-- def Subst.id : (Œì : Con Œ¶) ‚Üí  Subst Œ¶ Œì Œì := fun _ _ => (.var ¬∑)
-- prefix : max "ùüô‚Çõ" => Subst.id

-- def Term.subst‚ÇÄ : Œ¶ / Œì; A ‚ä¢ ‚Üí Œ¶ / Œì ‚ä¢ ‚Üí Œ¶ / Œì ‚ä¢:=
--   fun t s => t{{ùüô‚Çõ _; s}}‚Çõ
-- notation : max t "[[" s "]]‚Çõ" => Term.subst‚ÇÄ t s

-- def Typing.rename : {t : Œ¶ / Œì ‚ä¢} ‚Üí Typing t A ‚Üí (œÅ : Rename Œ® Œ¶ Œî Œì œÅ‚Çú) ‚Üí Typing t{{œÅ}}·µ£ A{{œÅ‚Çú}}·µ£‚Çú := by {
--   intro t h œÅ
--   induction h generalizing Œî Œ® with
--   | var i => apply Typing.var
--   | unit => constructor
--   | record f ih =>
--     constructor
--     intro i
--     apply ih
--   | proj r ih =>
--     constructor
--     apply ih
--   | pair a b iha ihb =>
--     constructor
--     apply iha
--     apply ihb
--   | p‚ÇÅ ab ih =>
--     constructor
--     apply ih
--   | p‚ÇÇ ab ih =>
--     constructor
--     apply ih
--   | true => constructor
--   | false => constructor
--   | ifte b t e ihb iht ihe =>
--     constructor
--     apply ihb
--     apply iht
--     apply ihe
--   | lam t ih =>
--     constructor
--     apply ih
--   | app f x ihf ihx =>
--     constructor
--     apply ihf
--     apply ihx
--   | lam‚Çú t ih =>
--     constructor
--     apply ih
--   | app‚Çú f ih =>
--     rw [Subst‚Çú.subst‚Çú‚ÇÄ_rename‚Çú]
--     constructor
--     apply ih
-- }

-- def Typing.wk : {t : Œ¶ / Œì ‚ä¢} ‚Üí {B : Ty Œ¶} ‚Üí Typing t A ‚Üí Typing (t.wk (B:=B)) A := by {
--   intro t B h
--   simp [Term.wk]
--   rw [‚ÜêRename‚Çú.id_rfl (A:=A)]
--   apply rename
--   assumption
-- }

-- inductive SmallStep : Œ¶ / Œì ‚ä¢ ‚Üí Œ¶ / Œì ‚ä¢ ‚Üí Prop where
--   | Œ≤_app : SmallStep (.app (.lam B e) x) e[[x]]‚Çõ
--   | Œ≤_app‚Çú : SmallStep (.app‚Çú (.lam‚Çú e) B) e[[B]]‚Çõ‚Çú
--   | Œ≤_proj : SmallStep (.proj (.record f) i) (f i)
--   | Œ≤_p‚ÇÅ : SmallStep (.p‚ÇÅ (.pair a b)) a
--   | Œ≤_p‚ÇÇ : SmallStep (.p‚ÇÇ (.pair a b)) b
--   | Œ≤_ifte‚ÇÅ : SmallStep (.ifte .true t e) t
--   | Œ≤_ifte‚ÇÇ : SmallStep (.ifte .false t e) e
--   | Œæ_record : SmallStep (f i) t ‚Üí SmallStep (.record f) (.record (update f i t))
--   | Œæ_proj : SmallStep r r' ‚Üí SmallStep (.proj r i) (.proj r' i)
--   | Œæ_pair‚ÇÅ : SmallStep a a' ‚Üí SmallStep (.pair a b) (.pair a' b)
--   | Œæ_pair‚ÇÇ : SmallStep b b' ‚Üí SmallStep (.pair a b) (.pair a b')
--   | Œæ_p‚ÇÅ : SmallStep ab ab' ‚Üí SmallStep (.p‚ÇÅ ab) (.p‚ÇÅ ab')
--   | Œæ_p‚ÇÇ : SmallStep ab ab' ‚Üí SmallStep (.p‚ÇÇ ab) (.p‚ÇÇ ab')
--   | Œæ_ifte‚ÇÄ : SmallStep b b' ‚Üí SmallStep (.ifte b t e) (.ifte b' t e)
--   | Œæ_ifte‚ÇÅ : SmallStep t t' ‚Üí SmallStep (.ifte b t e) (.ifte b t' e)
--   | Œæ_ifte‚ÇÇ : SmallStep e e' ‚Üí SmallStep (.ifte b t e) (.ifte b t e')
--   | Œæ_lam : SmallStep e e' ‚Üí SmallStep (.lam _ e) (.lam _ e')
--   | Œæ_app‚ÇÅ : SmallStep f f' ‚Üí SmallStep (.app f x) (.app f' x)
--   | Œæ_app‚ÇÇ : SmallStep x x' ‚Üí SmallStep (.app f x) (.app f x')
--   | Œæ_lam‚Çú : SmallStep e e' ‚Üí SmallStep (.lam‚Çú e) (.lam‚Çú e')
--   | Œæ_app‚Çú : SmallStep f f' ‚Üí SmallStep (.app‚Çú f B) (.app‚Çú f' B)
-- infix: 30 " ‚ü∂‚Çõ " => SmallStep

-- def MultiStep (t t' : Œ¶ / Œì ‚ä¢) := TransGen SmallStep t t'
-- infix: 30 " ‚ü∂‚Çõ+ " => MultiStep

-- def MultiStep0 (t t' : Œ¶ / Œì ‚ä¢) := ReflTransGen SmallStep t t'
-- infix: 30 " ‚ü∂‚Çõ* " => MultiStep0

-- def MultiStep.Œæ_app‚ÇÅ : MultiStep f f' ‚Üí MultiStep (.app f x) (.app f' x) :=
--   fun htt' =>
--   TransGen.lift (SystemF.Extrinsic.Term.app ¬∑ x) (fun _ _ htt' => .Œæ_app‚ÇÅ htt') htt'
-- def MultiStep.Œæ_app‚Çú : MultiStep f f' ‚Üí MultiStep (.app‚Çú f B) (.app‚Çú f' B) :=
--   fun htt' =>
--   TransGen.lift (SystemF.Extrinsic.Term.app‚Çú ¬∑ B) (fun _ _ htt' => .Œæ_app‚Çú htt') htt'
-- def MultiStep0.Œæ_app‚ÇÅ : MultiStep0 f f' ‚Üí MultiStep0 (.app f x) (.app f' x) :=
--   fun htt' =>
--   ReflTransGen.lift (SystemF.Extrinsic.Term.app ¬∑ x) (fun _ _ htt' => .Œæ_app‚ÇÅ htt') htt'
-- def MultiStep0.Œæ_app‚Çú : MultiStep0 f f' ‚Üí MultiStep0 (.app‚Çú f B) (.app‚Çú f' B) :=
--   fun htt' =>
--   ReflTransGen.lift (SystemF.Extrinsic.Term.app‚Çú ¬∑ B) (fun _ _ htt' => .Œæ_app‚Çú htt') htt'

-- -- def Subst.comp : Subst Œ¶'' Œ¶' Œì'' Œì' ‚Üí Rename‚Çú Œ¶'' Œ¶' ‚Üí Subst Œ¶' Œ¶ Œì' Œì ‚Üí Rename‚Çú Œ¶' Œ¶ ‚Üí Subst Œ¶'' Œ¶ Œì'' Œì √ó Rename‚Çú Œ¶'' Œ¶ :=
-- --   fun œÉ' œÅ' œÉ œÅ => .mk (fun i => (œÉ i).subst œÉ' œÅ') (Rename‚Çú.comp œÅ' œÅ)

-- -- def Subst.comp·µ£‚Çõ : Rename‚Çú Œ¶'' Œ¶' ‚Üí Subst‚Çú Œ¶' Œ¶ ‚Üí Subst‚Çú Œ¶'' Œ¶ :=
-- --   fun œÅ‚Çú œÉ‚Çú i => (œÉ‚Çú i).rename‚Çú œÅ‚Çú
-- -- def Subst.comp‚Çõ·µ£ : Subst‚Çú Œ¶'' Œ¶' ‚Üí Rename‚Çú Œ¶' Œ¶ ‚Üí Subst‚Çú Œ¶'' Œ¶ :=
-- --   fun œÉ‚Çú œÅ‚Çú => œÉ‚Çú ‚àò œÅ‚Çú

-- def Rename.comp {Œ¶'' Œ¶' Œ¶} {Œì'' : Con Œ¶''} {Œì' : Con Œ¶'} {Œì : Con Œ¶} {œÅ‚Çú' : Rename‚Çú Œ¶'' Œ¶'} {œÅ‚Çú : Rename‚Çú Œ¶' Œ¶} : Rename Œ¶'' Œ¶' Œì'' Œì' œÅ‚Çú' ‚Üí Rename Œ¶' Œ¶ Œì' Œì œÅ‚Çú ‚Üí Rename Œ¶'' Œ¶ Œì'' Œì (Rename‚Çú.comp œÅ‚Çú' œÅ‚Çú) :=
--   fun œÅ' œÅ =>
--   fun _ i => SystemF.Rename‚Çú.ren_comp ‚ñ∏ œÅ' _ (œÅ _ i)

-- #check cast_eq_iff_heq.mp
-- def Rename.extend_comp {Œ¶'' Œ¶' Œ¶} {Œì'' : Con Œ¶''} {Œì' : Con Œ¶'} {Œì : Con Œ¶} {œÅ‚Çú' : Rename‚Çú Œ¶'' Œ¶'} {œÅ‚Çú : Rename‚Çú Œ¶' Œ¶} {f : Rename Œ¶'' Œ¶' Œì'' Œì' œÅ‚Çú'} {g : Rename Œ¶' Œ¶ Œì' Œì œÅ‚Çú} {A : Ty Œ¶} : HEq (Rename.extend (A:=A) (comp f g)) (comp f.extend (g.extend (A:=A))) := by

--   -- refine HEq.symm (heq_of_eqRec_eq ?h‚ÇÅ ?h‚ÇÇ)
--   refine heq_of_eqRec_eq ?h‚ÇÅ ?h‚ÇÇ
--   rw [Rename‚Çú.ren_comp]
--   funext B i
--   cases i with
--   | zero =>
--     simp [Rename.extend, Rename.comp]
--     rw [@eqRec_eq_cast]
--   | succ i =>
--     simp [Rename.extend, Rename.comp]

--   -- funext fun i =>
--   -- match i with
--   -- | .zero => rfl
--   -- | .succ _ => rfl
-- def Rename.ren_comp {Œ¶'' Œ¶' Œ¶} {œÅ‚Çú' : Rename‚Çú Œ¶'' Œ¶'} {œÅ‚Çú : Rename‚Çú Œ¶' Œ¶} {Œì'' : Con Œ¶''} {Œì' : Con Œ¶'} {Œì : Con Œ¶} {f : Rename Œ¶'' Œ¶' Œì'' Œì' œÅ‚Çú'} {g : Rename Œ¶' Œ¶ Œì' Œì œÅ‚Çú} : {t : Œ¶ / Œì ‚ä¢} ‚Üí t{{comp f g}}·µ£ = t{{g}}·µ£{{f}}·µ£
--   | .var _ => by
--     simp [Term.rename]
--     constructor
--     exact Rename‚Çú.ren_comp
--     simp [comp]
--   | .unit => rfl
--   | .pair a b => congrArg‚ÇÇ Term.pair ren_comp ren_comp
--   | .p‚ÇÅ ab => congrArg _ ren_comp
--   | .p‚ÇÇ ab => congrArg _ ren_comp
--   | .record f => by
--     simp [Term.rename]
--     funext i
--     exact ren_comp
--   | .proj p i => by
--     simp [Term.rename]
--     exact ren_comp
--   | .false => rfl
--   | .true => rfl
--   | .ifte b t e => by
--     simp [Term.rename]
--     constructor
--     exact ren_comp
--     constructor
--     exact ren_comp
--     exact ren_comp
--   | .lam _ t => by
--     simp [Term.rename]
--     constructor
--     exact Rename‚Çú.ren_comp

--   | .app f x => sorry
--   | .lam‚Çú t => sorry
--   | .app‚Çú f B => sorry
--   -- | .record f => by
--   --   simp [Ty.rename‚Çú]
--   --   funext i
--   --   apply ren_comp
--   -- | .fn _ _ => congrArg‚ÇÇ Ty.fn ren_comp ren_comp
--   -- | .pi _ => congrArg Ty.pi (Eq.trans (congrArg _ extend_comp) ren_comp)
--   -- | .pair _ _  => congrArg‚ÇÇ Ty.pair ren_comp ren_comp

-- end Extrinsic

end SystemF
